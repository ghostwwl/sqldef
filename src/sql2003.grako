# The MIT License (MIT)
# Copyright (c) 2016, Victor M. Uriarte
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

@@grammar :: Sql
@@ignorecase :: True

@@whitespace :: /\s+/
@@eol_comments :: /--.*?$/
@@comments :: ?//\*[\s\S]*?\*//?
@@keyword :: SELECT FROM WHERE
#include :: "keyword_tokens2003.grako"

start =
        direct_sql_statement $
        ;

integer =
        /\d+/
        ;

par_integer =
        '(' integer ')'
        ;

par_integer_optional_integer =
        '(' integer [',' integer] ')'
        ;

@name
regular_identifier =
        /[a-z]\w*/
        ;

delimited_identifier =
        '"' char_in_delimited_identifier '"'
        ;

# not allowed to be empty
char_in_delimited_identifier =
        /(""|[^"\n])+/
        ;  #";  syntax highlither bug

literal =
        signed_numeric_literal
    |   general_literal
        ;

general_literal =
        character_string_literal
    |   'DATE' "'" date_value "'"
    |   'TIME' "'" unquoted_time_string "'"
    |   'TIMESTAMP' "'" unquoted_timestamp_string "'"
    |   interval_literal
    |   boolean_literal
        ;

character_string_literal =
        "'" [char_in_string] "'"
        ;

char_in_string =
        /(''|[^'\n])+/
        ;  #';  syntax highlither bug

signed_numeric_literal =
        [sign] unsigned_numeric_literal
        ;

unsigned_numeric_literal =
        exact_numeric_literal ['E' [sign] integer]
        ;

proper_decimal =
        integer ['.' [integer]]
        ;

exact_numeric_literal =
        proper_decimal
    |   '.' integer
        ;

time_zone_interval =
        sign integer ':' integer
        ;

date_value =
        integer '-' integer '-' integer
        ;

time_value =
        integer ':' integer ':' proper_decimal
        ;

interval_literal =
        'INTERVAL' [sign] "'" unquoted_interval_string "'" interval_qualifier
        ;

unquoted_time_string =
        time_value [time_zone_interval]
        ;

unquoted_timestamp_string =
        date_value unquoted_time_string
        ;

unquoted_interval_string =
        [sign] (year_month_literal | day_time_literal)
        ;

year_month_literal =
        [integer '-'] integer
        ;

day_time_literal =
        day_time_interval
    |   time_interval
        ;

day_time_interval =
        integer [integer [':' integer [':' proper_decimal]]]
        ;

time_interval =
        integer [':' integer [':' proper_decimal]]
    |   integer [':' proper_decimal]
    |   proper_decimal
        ;

identifier =
        regular_identifier
    |   delimited_identifier
        ;

identifier_list =
        ','.{identifier}
        ;

identifier_chain =
        '.'.{identifier}
        ;

identifier_chain_list =
        ','.{identifier_chain}
        ;

qualified_name =
        ['MODULE' '.'] identifier_chain
        ;

parameter_name =
        ':' identifier
        ;

parameter_name_list =
        ','.{parameter_name}
        ;

par_identifier_list =
        '(' identifier_list ')'
        ;

external_routine_name =
        identifier
    |   character_string_literal
        ;

sql_statement_name =
        identifier
    |   descriptor_name
        ;

dynamic_cursor_name =
        qualified_name
    |   descriptor_name
        ;

descriptor_name =
        [_KW_GLOBAL_OR_LOCAL] simple_value_specification
        ;

data_type =
        reference_type
    |   predefined_type
    |   identifier_chain
    |   'ROW' '(' ','.{identifier data_type [_KW_REFERENCE_SCOPE_CHECK]} ')'
    |   data_type ('ARRAY' | 'MULTISET') [l_bracket_trigraph integer r_bracket_trigraph]
        ;

predefined_type =
        'INT'
    |   'DATE'
    |   'REAL'
    |   'BIGINT'
    |   'BOOLEAN'
    |   'INTEGER'
    |   'SMALLINT'
    |   'DOUBLE' 'PRECISION'
    |   'FLOAT' [par_integer]
    |   'INTERVAL' interval_qualifier
    |   ('NUMERIC' | 'DECIMAL' | 'DEC') [par_integer_optional_integer]
    |   ('TIME' | 'TIMESTAMP') [par_integer] [_KW_WITH_WITHOUT 'TIME' 'ZONE']
    |   char_str_type ['CHARACTER' 'SET' identifier_chain] ['COLLATE' identifier_chain]
        ;

char_str_type =
        _KW_CHAR [par_integer]
    |   _KW_VCHAR par_integer
    |   _KW_NCLOB [lob_length]
    |   _KW_CLOB [lob_length]
    |   _KW_BLOB [lob_length]
    |   _KW_NCHAR ['VARYING'] [par_integer]
        ;

lob_length =
        '(' integer ['K' | 'M' | 'G'] [_KW_CHAR_LENGTH_UNITS] ')'
        ;

reference_type =
        'REF' '(' identifier_chain ')' ['SCOPE' qualified_name]
        ;

value_expression_primary =
        par_value_expression
    |   nonpar_value_expression_primary
        ;

par_value_expression =
        '(' value_expression ')'
        ;

nonpar_value_expression_primary =
        qualified_name
    |   ('NULLIF' | 'COALESCE') '(' value_expression_list ')'
    |   case_specification
    |   window_function
    |   method_invocation
    |   aggregate_function
    |   'GROUPING' '(' ','.{qualified_name} ')'
    |   unsigned_value_specification
    |   ('MULTISET' | 'ARRAY') l_bracket_trigraph value_expression_list r_bracket_trigraph
    |   ['TABLE' | 'MULTISET' | 'ARRAY'] subquery
    |   value_expression_primary '.' identifier
    |   ['NEW'] routine_invocation
    |   'NEXT' 'VALUE' 'FOR' identifier_chain
    |   'DEREF' '(' value_expression_primary ')'
    |   'ELEMENT' '(' multiset_value_expression ')'
    |   'CAST' '(' cast_operand 'AS' data_type ')'
    |   'TREAT' '(' value_expression 'AS' target_subtype ')'
    |   identifier_chain '::' identifier ['(' [sql_argument_list] ')']
    |   array_value_expression l_bracket_trigraph numeric_value_expression r_bracket_trigraph
    |   value_expression_primary dereference_operator identifier ['(' [sql_argument_list] ')']
        ;

value_specification =
        literal
    |   general_value_specification
        ;

unsigned_value_specification =
        unsigned_numeric_literal
    |   general_literal
    |   general_value_specification
        ;

general_value_specification =
        parameter_specification
    |   '?'
    |   'USER'
    |   'VALUE'
    |   'SYSTEM_USER'
    |   'SESSION_USER'
    |   'CURRENT_PATH'
    |   'CURRENT_ROLE'
    |   'CURRENT_USER'
    |   'CURRENT_DEFAULT_TRANSFORM_GROUP'
    |   ['CURRENT_TRANSFORM_GROUP_FOR_TYPE'] identifier_chain
    |   'CURRENT_COLLATION' '(' character_value_expression ')'
        ;

simple_value_specification =
        literal
    |   parameter_name
    |   identifier_chain
        ;

target_specification =
        simple_target_specification
    |   qualified_name l_bracket_trigraph simple_value_specification r_bracket_trigraph
    |   '?'
        ;

simple_target_specification =
        parameter_specification
    |   qualified_name
        ;

parameter_specification =
        parameter_name [['INDICATOR'] parameter_name]
        ;

window_function =
        window_function_type 'OVER' window_name_or_specification
        ;

window_function_type =
        (_KW_RANK_FUNCTION_TYPE | 'ROW_NUMBER') empty_grouping_set
    |   aggregate_function
        ;

window_name_or_specification =
        identifier
    |   window_specification
        ;

value_expression_list =
        ','.{value_expression}
        ;

case_specification =
        'CASE' [case_operand]
            {when_clause}+
            [else_clause]
            'END'
        ;

when_clause =
        'WHEN' when_operand 'THEN' result
        ;

else_clause =
        'ELSE' result
        ;

case_operand =
        row_value_predicand ['OVERLAPS' row_value_predicand]
        ;

when_operand =
        row_value_predicand
    |   predicate_when_operand
    |   boolean_value_expression
        ;

predicate_when_operand =
        comp_op (_KW_QUANTIFIER subquery | row_value_predicand)
    |   'OVERLAPS' row_value_predicand
    |   ['NOT'] 'IN' in_predicate_value
    |   ['NOT'] ('MEMBER' | 'SUBMULTISET') ['OF'] multiset_value_expression
    |   ['NOT'] ('LIKE' | 'SIMILAR' 'TO') character_value_expression ['ESCAPE' character_value_expression]
    |   ['NOT'] 'BETWEEN' ['ASYMMETRIC' | 'SYMMETRIC'] row_value_predicand 'AND' row_value_predicand
    |   'MATCH' ['UNIQUE'] ['SIMPLE' | 'PARTIAL' | 'FULL'] subquery
    |   'IS' ['NOT'] ('A' 'SET' | 'OF' '(' type_list ')' | 'NULL')
    |   'IS' 'DISTINCT' 'FROM' row_value_predicand
        ;

result =
        value_expression
    |   'NULL'
        ;

cast_operand =
        value_expression
    |   _KW_IMPLICITLY_TYPED_VALUE_SPECIFICATION
        ;

target_subtype =
        identifier_chain
    |   reference_type
        ;

method_invocation =
        value_expression_primary '.' identifier ['(' [sql_argument_list] ')']
    |   '(' value_expression_primary 'AS' data_type ')' '.' identifier ['(' [sql_argument_list] ')']
        ;

value_expression =
        common_value_expression
    |   boolean_value_expression
    |   row_value_expression
        ;

common_value_expression =
        numeric_value_expression
    |   value_expression_primary
    |   datetime_interval_expr
    |   character_value_expression
    |   collection_value_expression
        ;

collection_value_expression =
        array_value_expression
    |   multiset_value_expression
        ;

numeric_value_expression =
        [numeric_value_expression sign] term
        ;

par_numeric_value_expression_list =
        '(' ','.{numeric_value_expression} ')'
        ;

term =
        [term mult_div] factor
        ;

factor =
        [sign] numeric_primary
        ;

numeric_primary =
        value_expression_primary
    |   position_expression
    |   length_expression
    |   _KW_NUMERIC_FUNCTION par_numeric_value_expression_list
    |   'CARDINALITY' '(' collection_value_expression ')'
    |   'EXTRACT' '(' _KW_EXTRACT_FIELD 'FROM' datetime_interval_expr ')'
        ;

position_expression =
        'POSITION' '(' character_value_expression 'IN' character_value_expression ['USING' _KW_CHAR_LENGTH_UNITS] ')'
        ;

length_expression =
        ('CHAR_LENGTH' | 'CHARACTER_LENGTH' | 'OCTET_LENGTH')
            '(' character_value_expression ['USING' _KW_CHAR_LENGTH_UNITS] ')'
        ;

datetime_interval_expr =
        datetime_value_expression
    |   interval_value_expression
        ;

character_value_expression =
        [character_value_expression '||'] character_primary ['COLLATE' identifier_chain]
        ;

character_primary =
        value_expression_primary
    |   character_overlay_function
    |   character_substring_function
    |   regular_expression_substring_function
    |   ('UPPER' | 'LOWER' | 'NORMALIZE') '(' character_value_expression ')'
    |   ('CONVERT' | 'TRANSLATE') '(' character_value_expression 'USING' identifier_chain ')'
    |   'TRIM' '(' [[_KW_TRIM_SPECIFICATION] [character_value_expression] 'FROM'] character_value_expression ')'
    |   value_expression_primary '.' 'SPECIFICTYPE'
        ;

character_substring_function =
        'SUBSTRING' '(' character_value_expression 'FROM' numeric_value_expression
            ['FOR' numeric_value_expression] ['USING' _KW_CHAR_LENGTH_UNITS] ')'
        ;

regular_expression_substring_function =
        'SUBSTRING' '(' character_value_expression
            'SIMILAR' character_value_expression 'ESCAPE' character_value_expression ')'
        ;

character_overlay_function =
        'OVERLAY' '(' character_value_expression 'PLACING' character_value_expression
            'FROM' numeric_value_expression ['FOR' numeric_value_expression] ['USING' _KW_CHAR_LENGTH_UNITS] ')'
        ;

datetime_value_expression =
        [interval_value_expression '+'] datetime_factor
    |   datetime_value_expression sign interval_term
        ;

datetime_factor =
        datetime_primary ['AT' time_zone_specifier]
        ;

datetime_primary =
        value_expression_primary
    |   datetime_value_function
        ;

time_zone_specifier =
        'LOCAL'
    |   'TIME' 'ZONE' interval_primary
        ;

datetime_value_function =
        'CURRENT_DATE'
    |   ('CURRENT_TIME' | 'CURRENT_TIMESTAMP' | 'LOCALTIME' | 'LOCALTIMESTAMP') [par_integer]
        ;

interval_value_expression =
        [interval_value_expression sign] interval_term
    |   '(' datetime_value_expression '-' datetime_factor ')' interval_qualifier
        ;

interval_term =
        interval_term mult_div factor
    |   [term '*'] [sign] interval_primary
        ;

interval_primary =
        value_expression_primary [interval_qualifier]
    |   'ABS' '(' interval_value_expression ')'
        ;

boolean_value_expression =
        [boolean_value_expression 'OR'] boolean_term
        ;

boolean_term =
        [boolean_term 'AND'] ['NOT'] boolean_primary ['IS' ['NOT'] boolean_literal]
        ;

boolean_primary =
        predicate
    |   boolean_predicand
        ;

boolean_predicand =
        par_boolean_value_expression
    |   nonpar_value_expression_primary
        ;

par_boolean_value_expression =
        '(' boolean_value_expression ')'
        ;

array_value_expression =
        [array_value_expression '||'] value_expression_primary
        ;

multiset_value_expression =
        [multiset_value_expression 'MULTISET' _KW_UNION_EXCEPT
            [_KW_ALL_DISTINCT]] multiset_term
        ;

multiset_term =
        [multiset_term 'MULTISET' 'INTERSECT' [_KW_ALL_DISTINCT]]
            multiset_primary
        ;

multiset_primary =
        'SET' '(' multiset_value_expression ')'
    |   value_expression_primary
        ;

explicit_row_value_constructor =
        subquery
    |   ['ROW'] '(' value_expression_list ')'
        ;

contextually_typed_row_value_constructor_list =
        ','.{contextually_typed_row_value_constructor_element}
        ;

contextually_typed_row_value_constructor_element =
        value_expression
    |   _KW_CONTEXTUALLY_TYPED_VALUE_SPECIFICATION
        ;

row_value_expression =
        nonpar_value_expression_primary
    |   explicit_row_value_constructor
        ;

table_row_value_expression =
        nonpar_value_expression_primary
    |   common_value_expression
    |   boolean_value_expression
    |   explicit_row_value_constructor
        ;

contextually_typed_row_value_expression =
        nonpar_value_expression_primary
    |   common_value_expression
    |   boolean_value_expression
    |   _KW_CONTEXTUALLY_TYPED_VALUE_SPECIFICATION
    |   ['ROW'] '(' contextually_typed_row_value_constructor_list ')'
        ;

row_value_predicand =
        nonpar_value_expression_primary
    |   common_value_expression
    |   boolean_predicand
    |   explicit_row_value_constructor
        ;

table_expression =
        from_clause
            [where_clause]
            [group_by_clause]
            [having_clause]
            [window_clause]
        ;

from_clause =
        'FROM' ','.{table_reference}
        ;

table_reference =
        table_primary_or_joined_table [sample_clause]
        ;

table_primary_or_joined_table =
        table_primary
    |   joined_table
        ;

sample_clause =
        'TABLESAMPLE' _KW_SAMPLE_METHOD par_numeric_value_expression_list
            ['REPEATABLE' par_numeric_value_expression_list]
        ;

table_primary =
        qualified_name [as_clause [par_identifier_list]]
    |   'ONLY' '(' qualified_name ')' [as_clause [par_identifier_list]]
    |   ['LATERAL'] subquery as_clause [par_identifier_list]
    |   ('UNNEST' | 'TABLE') '(' collection_value_expression ')' ['WITH' 'ORDINALITY'] as_clause [par_identifier_list]
    |   '(' joined_table ')'
        ;

joined_table =
        table_reference (qualified_join | unqualified_join)
        ;

unqualified_join =
        _KW_UNQUALIFIED_JOIN table_primary
        ;

qualified_join =
        [_KW_JOIN_TYPE] 'JOIN' table_reference join_specification
        ;

join_specification =
        'ON' boolean_value_expression
    |   'USING' par_identifier_list
        ;

where_clause =
        'WHERE' boolean_value_expression
        ;

group_by_clause =
        'GROUP' 'BY' [_KW_SET_QUANTIFIER] ','.{grouping_element}
        ;

grouping_element =
        ordinary_grouping_set
    |   ('ROLLUP' | 'CUBE') '(' ordinary_grouping_set_list ')'
    |   empty_grouping_set
    |   'GROUPING' 'SETS' '(' ','.{grouping_element} ')'
        ;

ordinary_grouping_set =
        grouping_column_reference
    |   '(' grouping_column_reference_list ')'
        ;

grouping_column_reference =
        qualified_name ['COLLATE' identifier_chain]
        ;

grouping_column_reference_list =
        ','.{grouping_column_reference}
        ;

ordinary_grouping_set_list =
        ','.{ordinary_grouping_set}
        ;

having_clause =
        'HAVING' boolean_value_expression
        ;

window_clause =
        'WINDOW' ','.{window_definition}
        ;

window_definition =
        identifier 'AS' window_specification
        ;

window_specification =
        '(' [identifier] [window_partition_clause] [order_by_clause] [window_frame_clause] ')'
        ;

window_partition_clause =
        'PARTITION' 'BY' grouping_column_reference_list
        ;

window_frame_clause =
        _KW_WINDOW_FRAME_UNITS
            window_frame_extent
            ['EXCLUDE' ['CURRENT' 'ROW' | 'GROUP' | 'TIES' | 'NO' 'OTHERS']]
        ;

window_frame_extent =
        window_frame_start
    |   'BETWEEN' window_frame_bound 'AND' window_frame_bound
        ;

window_frame_start =
        'UNBOUNDED' 'PRECEDING'
    |   unsigned_value_specification 'PRECEDING'
    |   'CURRENT' 'ROW'
        ;

window_frame_bound =
        window_frame_start
    |   'UNBOUNDED' 'FOLLOWING'
    |   unsigned_value_specification 'FOLLOWING'
        ;

select_list =
        '*'
    |   ','.{select_sublist}
        ;

select_sublist =
        value_expression [as_clause]
    |   identifier_chain '.' '*'
    |   value_expression_primary '.' '*' ['AS' par_identifier_list]
        ;

as_clause =
        ['AS'] identifier
        ;

query_expression =
        [with_clause] query_expression_body
        ;

with_clause =
        'WITH' ['RECURSIVE'] with_list
        ;

with_list =
        ','.{with_element}
        ;

with_element =
        identifier [par_identifier_list]
            'AS' subquery [search_or_cycle_clause]
        ;

query_expression_body =
        non_join_query_expression
    |   joined_table
        ;

non_join_query_expression =
        non_join_query_term
    |   query_expression_body _KW_UNION_EXCEPT [_KW_ALL_DISTINCT] ['CORRESPONDING' ['BY' par_identifier_list]] query_term
        ;

query_term =
        non_join_query_term
    |   joined_table
        ;

non_join_query_term =
        non_join_query_primary
    |   query_term 'INTERSECT' [_KW_ALL_DISTINCT] ['CORRESPONDING' ['BY' par_identifier_list]] query_primary
        ;

query_primary =
        non_join_query_primary
    |   joined_table
        ;

non_join_query_primary =
        'SELECT' [_KW_SET_QUANTIFIER] select_list table_expression
    |   'VALUES' ','.{table_row_value_expression}
    |   'TABLE' qualified_name
    |   '(' non_join_query_expression ')'
        ;

search_or_cycle_clause =
        search_clause
    |   cycle_clause
        ;

search_clause =
        'SEARCH' ('DEPTH' | 'BREADTH') 'FIRST' 'BY'
            sort_specification_list
            'SET' identifier
            [cycle_clause]
        ;

cycle_clause =
        'CYCLE' identifier_list
            'SET' identifier 'TO' value_expression
            'DEFAULT' value_expression
            'USING' identifier
        ;

subquery =
        '(' query_expression ')'
        ;

predicate =
        row_value_predicand predicate_when_operand
    |   character_value_expression 'IS' ['NOT'] 'NORMALIZED'
    |   ('EXISTS' | 'UNIQUE') subquery
        ;

in_predicate_value =
        subquery
    |   '(' in_value_list ')'
        ;

in_value_list =
        ','.{row_value_expression}
        ;

type_list =
        ','.{['ONLY'] identifier_chain}
        ;

interval_qualifier =
        _KW_NON_SECOND_PRIMARY_DATETIME_FIELD [par_integer] ['TO' end_field]
    |   'SECOND' [par_integer_optional_integer]
        ;

end_field =
        _KW_NON_SECOND_PRIMARY_DATETIME_FIELD
    |   'SECOND' [par_integer]
        ;

routine_invocation =
        identifier_chain '(' [sql_argument_list] ')'
        ;

sql_argument_list =
        ','.{sql_argument}
        ;

sql_argument =
        value_expression ['AS' identifier_chain]
    |   target_specification
        ;

specific_routine_designator =
        'SPECIFIC' _KW_ROUTINE_TYPE identifier_chain
    |   _KW_ROUTINE_TYPE identifier_chain ['(' [data_type_list] ')'] ['FOR' identifier_chain]
        ;

data_type_list =
        ','.{data_type}
        ;

aggregate_function =
        'COUNT' '(' '*' ')' [filter_clause]
    |   _KW_SET_COMPUTATIONAL_OPERATION '(' [_KW_SET_QUANTIFIER] value_expression ')' [filter_clause]
    |   _KW_BINARY_SET_FUNCTION_TYPE par_numeric_value_expression_list [filter_clause]
    |   _KW_RANK_FUNCTION_TYPE '(' value_expression_list ')' within_group_specification [filter_clause]
    |   _KW_INVERSE_DISTRIBUTION_FUNCTION_TYPE par_numeric_value_expression_list within_group_specification [filter_clause]
        ;

filter_clause =
        'FILTER' '(' where_clause ')'
        ;

within_group_specification =
        'WITHIN' 'GROUP' '(' order_by_clause ')'
        ;

sort_specification_list =
        ','.{value_expression [_KW_ORDERING_SPECIFICATION] ['NULLS' ('FIRST' | 'LAST')]}
        ;

schema_character_set_or_path =
        schema_character_set_specification ['PATH' identifier_chain_list]
    |   'PATH' identifier_chain_list [schema_character_set_specification]
        ;

schema_name_clause =
        identifier_chain
    |   [identifier_chain] 'AUTHORIZATION' identifier
        ;

schema_character_set_specification =
        'DEFAULT' 'CHARACTER' 'SET' identifier_chain
        ;

schema_element =
        table_definition
    |   schema_routine
    |   view_definition
    |   grant_statement
    |   role_definition
    |   domain_definition
    |   trigger_definition
    |   assertion_definition
    |   collation_definition
    |   transform_definition
    |   character_set_definition
    |   transliteration_definition
    |   sequence_generator_definition
    |   user_defined_cast_definition
    |   user_defined_type_definition
    |   user_defined_ordering_definition
        ;

table_definition =
        'CREATE' [_KW_GLOBAL_OR_LOCAL 'TEMPORARY'] 'TABLE'
            qualified_name table_contents_source
            ['ON' 'COMMIT' _KW_TABLE_COMMIT_ACTION 'ROWS']
        ;

table_contents_source =
        '(' table_element_list ')'
    |   'OF' identifier_chain ['UNDER' qualified_name] ['(' table_element_list ')']
    |   [par_identifier_list] 'AS' subquery 'WITH' ['NO'] 'DATA'
        ;

table_element_list =
        ','.{table_element}
        ;

table_element =
        column_definition
    |   table_constraint_definition
    |   'LIKE' qualified_name [_KW_LIKE_OPTIONS]
    |   self_referencing_column_specification
    |   identifier 'WITH' 'OPTIONS' ['SCOPE' qualified_name] [default_clause] [{column_constraint_definition}+]
        ;

self_referencing_column_specification =
        'REF' 'IS' identifier _KW_REFERENCE_GENERATION
        ;

column_definition =
        identifier [data_type | identifier_chain] [_KW_REFERENCE_SCOPE_CHECK]
            [default_clause | identity_column_specification | 'GENERATED' 'ALWAYS' 'AS' par_value_expression]
            [{column_constraint_definition}+] ['COLLATE' identifier_chain]
        ;

column_constraint_definition =
        ['CONSTRAINT' identifier_chain] column_constraint
            [_KW_CONSTRAINT_CHARACTERISTICS]
        ;

column_constraint =
        'NOT' 'NULL'
    |   _KW_UNIQUE_SPECIFICATION
    |   references_specification
    |   'CHECK' par_boolean_value_expression
        ;

identity_column_specification =
        'GENERATED' ('ALWAYS' | 'BY' 'DEFAULT') 'AS' 'IDENTITY'
            ['(' {common_sequence_generator_option}+ ')']
        ;

default_clause =
        'DEFAULT' default_option
        ;

default_option =
        literal
    |   datetime_value_function
    |   'USER'
    |   'CURRENT_USER'
    |   'CURRENT_ROLE'
    |   'SESSION_USER'
    |   'SYSTEM_USER'
    |   'CURRENT_PATH'
    |   _KW_IMPLICITLY_TYPED_VALUE_SPECIFICATION
        ;

table_constraint_definition =
        ['CONSTRAINT' identifier_chain] table_constraint
            [_KW_CONSTRAINT_CHARACTERISTICS]
        ;

table_constraint =
        _KW_UNIQUE_SPECIFICATION par_identifier_list
    |   'UNIQUE' 'VALUE'
    |   'FOREIGN' 'KEY' par_identifier_list references_specification
    |   'CHECK' par_boolean_value_expression
        ;

references_specification =
        'REFERENCES' qualified_name [par_identifier_list]
            ['MATCH' _KW_MATCH_TYPE]
            [_KW_REFERENTIAL_TRIGGERED_ACTION]
        ;

alter_table_action =
        'ADD' ['COLUMN'] column_definition
    |   'ALTER' ['COLUMN'] identifier alter_column_action
    |   'DROP' ['COLUMN'] identifier _KW_DROP_BEHAVIOR
    |   'ADD' table_constraint_definition
    |   'DROP' 'CONSTRAINT' identifier_chain _KW_DROP_BEHAVIOR
        ;

alter_column_action =
        'SET' default_clause
    |   _KW_DROP_DEFAULT_CLAUSE
    |   'ADD' 'SCOPE' qualified_name
    |   'DROP' 'SCOPE' _KW_DROP_BEHAVIOR
    |   {alter_identity_column_option}+
        ;

alter_identity_column_option =
        'RESTART' 'WITH' signed_numeric_literal
    |   'SET' basic_sequence_generator_option
        ;

view_definition =
        'CREATE' ['RECURSIVE'] 'VIEW' qualified_name
            view_specification 'AS' query_expression
            ['WITH' [_KW_LEVELS_CLAUSE] 'CHECK' 'OPTION']
        ;

view_specification =
        [par_identifier_list]
    |   'OF' identifier_chain ['UNDER' qualified_name] ['(' ','.{view_element} ')']
        ;

view_element =
        self_referencing_column_specification
    |   identifier 'WITH' 'OPTIONS' 'SCOPE' qualified_name
        ;

domain_definition =
        'CREATE' 'DOMAIN' identifier_chain ['AS'] data_type
            [default_clause] [{domain_constraint}+]
            ['COLLATE' identifier_chain]
        ;

domain_constraint =
        ['CONSTRAINT' identifier_chain]
            'CHECK' par_boolean_value_expression
            [_KW_CONSTRAINT_CHARACTERISTICS]
        ;

alter_domain_action =
        'SET' default_clause
    |   _KW_DROP_DEFAULT_CLAUSE
    |   'ADD' domain_constraint
    |   'DROP' 'CONSTRAINT' identifier_chain
        ;

character_set_definition =
        'CREATE' 'CHARACTER' 'SET' identifier_chain ['AS']
            'GET' identifier_chain ['COLLATE' identifier_chain]
        ;

collation_definition =
        'CREATE' 'COLLATION' identifier_chain 'FOR' identifier_chain
            'FROM' identifier_chain [_KW_PAD_CHARACTERISTIC]
        ;

transliteration_definition =
        'CREATE' 'TRANSLATION' identifier_chain 'FOR' identifier_chain
            'TO' identifier_chain 'FROM' transliteration_source
        ;

transliteration_source =
        identifier_chain
    |   specific_routine_designator
        ;

assertion_definition =
        'CREATE' 'ASSERTION' identifier_chain 'CHECK'
            par_boolean_value_expression
            [_KW_CONSTRAINT_CHARACTERISTICS]
        ;

trigger_definition =
        'CREATE' 'TRIGGER' identifier_chain
            _KW_TRIGGER_ACTION_TIME trigger_event 'ON' qualified_name
            ['REFERENCING' {_KW_OLD_NEW ['ROW' | 'TABLE'] as_clause}+]
            triggered_action
        ;

trigger_event =
        'INSERT'
    |   'DELETE'
    |   'UPDATE' ['OF' identifier_list]
        ;

triggered_action =
        ['FOR' 'EACH' ('ROW' | 'STATEMENT')]
            ['WHEN' par_boolean_value_expression]
            triggered_sql_statement
        ;

triggered_sql_statement =
        sql_executable_statement
    |   'BEGIN' 'ATOMIC' {sql_executable_statement ';'}+ 'END'
        ;

user_defined_type_definition =
        'CREATE' 'TYPE' user_defined_type_body
        ;

user_defined_type_body =
        identifier_chain ['UNDER' identifier_chain]
            ['AS' representation] [{user_defined_type_option}+]
            [','.{method_specification}]
        ;

user_defined_type_option =
        ['NOT'] 'INSTANTIABLE'
    |   ['NOT'] 'FINAL'
    |   reference_type_specification
    |   [cast_to_distinct] [cast_to_source]
    |   [cast_as_ref] [cast_to_type]
        ;

representation =
        predefined_type
    |   '(' ','.{attribute_definition} ')'
        ;

reference_type_specification =
        'REF' 'USING' predefined_type
    |   'REF' 'FROM' par_identifier_list
    |   'REF' 'IS' 'SYSTEM' 'GENERATED'
        ;

cast_as_ref =
        'CAST' '(' 'SOURCE' 'AS' 'REF' ')'
            'WITH' identifier
        ;

cast_to_type =
        'CAST' '(' 'REF' 'AS' 'SOURCE' ')'
            'WITH' identifier
        ;

cast_to_distinct =
        'CAST' '(' 'SOURCE' 'AS' 'DISTINCT' ')'
            'WITH' identifier
        ;

cast_to_source =
        'CAST' '(' 'DISTINCT' 'AS' 'SOURCE' ')'
            'WITH' identifier
        ;

method_specification =
        original_method_specification
    |   'OVERRIDING' partial_method_specification
        ;

original_method_specification =
        partial_method_specification
            ['SELF' 'AS' 'RESULT']
            ['SELF' 'AS' 'LOCATOR']
            [{_KW_METHOD_CHARACTERISTIC}+]
        ;

partial_method_specification =
        ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR'] 'METHOD'
            identifier '(' [sql_parameter_declaration_list] ')'
            'RETURNS' returns_type ['SPECIFIC' identifier_chain]
        ;

attribute_definition =
        identifier data_type [_KW_REFERENCE_SCOPE_CHECK]
            [default_clause] ['COLLATE' identifier_chain]
        ;

alter_type_action =
        'ADD' 'ATTRIBUTE' attribute_definition
    |   'DROP' 'ATTRIBUTE' identifier 'RESTRICT'
    |   'ADD' method_specification
    |   'DROP' ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR'] 'METHOD' identifier '(' [data_type_list] ')' 'RESTRICT'
        ;

schema_routine =
        'CREATE' 'PROCEDURE' identifier_chain '(' [sql_parameter_declaration_list] ')' [{routine_characteristic}+] routine_body
    |   'CREATE' (function_specification | method_specification_designator) routine_body
        ;

sql_parameter_declaration_list =
        ','.{[_KW_PARAMETER_MODE] [identifier] parameter_type ['RESULT']}
        ;

parameter_type =
        data_type ['AS' 'LOCATOR']
        ;

function_specification =
        'FUNCTION' identifier_chain
            '(' [sql_parameter_declaration_list] ')' 'RETURNS' returns_type
            [{routine_characteristic}+] ['STATIC' 'DISPATCH']
        ;

method_specification_designator =
        'SPECIFIC' 'METHOD' identifier_chain
    |   ['INSTANCE' | 'STATIC' | 'CONSTRUCTOR'] 'METHOD' identifier '(' [sql_parameter_declaration_list] ')'
            ['RETURNS' returns_type] 'FOR' identifier_chain
        ;

routine_characteristic =
        _KW_PARAMETER_STYLE_CLAUSE
    |   _KW_NULL_CALL_CLAUSE
    |   _KW_OLD_NEW 'SAVEPOINT' 'LEVEL'
    |   _KW_SQL_DATA_ACCESS_INDICATION
    |   _KW_DETERMINISTIC_CHARACTERISTIC
    |   'SPECIFIC' identifier_chain
    |   'DYNAMIC' 'RESULT' 'SETS' integer
        ;

returns_type =
        parameter_type ['CAST' 'FROM' parameter_type]
    |   'TABLE' '(' ','.{identifier data_type} ')'
        ;

routine_body =
        [_KW_RIGHTS_CLAUSE] sql_executable_statement
    |   external_body_reference
        ;

external_body_reference =
        'EXTERNAL' ['NAME' external_routine_name] [_KW_PARAMETER_STYLE_CLAUSE]
            ['TRANSFORM' 'GROUP' (identifier | multiple_group_specification)]
            [_KW_EXTERNAL_SECURITY_CLAUSE]
        ;

multiple_group_specification =
        ','.{identifier 'FOR' 'TYPE' identifier_chain}
        ;

alter_routine_statement =
        'ALTER' specific_routine_designator
            {alter_routine_characteristic}+ 'RESTRICT'
        ;

alter_routine_characteristic =
        _KW_PARAMETER_STYLE_CLAUSE
    |   _KW_SQL_DATA_ACCESS_INDICATION
    |   _KW_NULL_CALL_CLAUSE
    |   'DYNAMIC' 'RESULT' 'SETS' integer
    |   'NAME' external_routine_name
        ;

user_defined_cast_definition =
        'CREATE' 'CAST' '(' data_type 'AS' data_type ')'
            'WITH' specific_routine_designator ['AS' 'ASSIGNMENT']
        ;

drop_user_defined_cast_statement =
        'CAST' '(' data_type 'AS' data_type ')' _KW_DROP_BEHAVIOR
        ;

user_defined_ordering_definition =
        'CREATE' 'ORDERING' 'FOR' identifier_chain ordering_form
        ;

ordering_form =
        ('EQUALS' 'ONLY' | 'ORDER' 'FULL') 'BY' ordering_category
        ;

ordering_category =
        ('RELATIVE' | 'MAP')'WITH' specific_routine_designator
    |   'STATE' [identifier_chain]
        ;

transform_definition =
        'CREATE' ('TRANSFORM' | 'TRANSFORMS') 'FOR'
            identifier_chain {identifier '(' transform_element_list ')'}+
        ;

transform_element_list =
        ','.{_KW_TRANSFORM_KIND 'WITH' specific_routine_designator}
        ;

alter_transform_statement =
        ('TRANSFORM' | 'TRANSFORMS') 'FOR'
            identifier_chain {identifier '(' ','.{alter_transform_action} ')'}+
        ;

alter_transform_action =
        'ADD' '(' transform_element_list ')'
    |   'DROP' '(' _KW_TRANSFORM_KIND [',' _KW_TRANSFORM_KIND] _KW_DROP_BEHAVIOR ')'
        ;

drop_transform_statement =
        ('TRANSFORM' | 'TRANSFORMS') transforms_to_be_dropped 'FOR'
            identifier_chain
        ;

transforms_to_be_dropped =
        'ALL'
    |   identifier
        ;

sequence_generator_definition =
        'CREATE' 'SEQUENCE' identifier_chain [{sequence_generator_option}+]
        ;

sequence_generator_option =
        'AS' data_type
    |   {common_sequence_generator_option}+
        ;

common_sequence_generator_option =
        'START' 'WITH' signed_numeric_literal
    |   basic_sequence_generator_option
        ;

basic_sequence_generator_option =
        'INCREMENT' 'BY' signed_numeric_literal
    |   sequence_generator_max_min_value_option
    |   ['NO'] 'CYCLE'
        ;

sequence_generator_max_min_value_option =
        ('MAXVALUE' | 'MINVALUE') signed_numeric_literal
    |   'NO' ('MAXVALUE' | 'MINVALUE')
        ;

alter_sequence_generator_option =
        'RESTART' 'WITH' signed_numeric_literal
    |   basic_sequence_generator_option
        ;

grant_statement =
        grant_privilege_statement
    |   grant_role_statement
        ;

grant_privilege_statement =
        'GRANT' privileges 'TO' grantee_list
            ['WITH' 'HIERARCHY' 'OPTION']
            ['WITH' 'GRANT' 'OPTION']
            ['GRANTED' 'BY' _KW_GRANTOR]
        ;

privileges =
        object_privileges 'ON' object_name
        ;

object_name =
        ['TABLE'] qualified_name
    |   'DOMAIN' identifier_chain
    |   'COLLATION' identifier_chain
    |   'CHARACTER' 'SET' identifier_chain
    |   'TRANSLATION' identifier_chain
    |   'TYPE' identifier_chain
    |   'SEQUENCE' identifier_chain
    |   specific_routine_designator
        ;

object_privileges =
        'ALL' 'PRIVILEGES'
    |   ','.{action}
        ;

action =
        'SELECT' [par_identifier_list]
    |   'INSERT' [par_identifier_list]
    |   'UPDATE' [par_identifier_list]
    |   'REFERENCES' [par_identifier_list]
    |   'SELECT' '(' ','.{specific_routine_designator} ')'
    |   'DELETE'
    |   'USAGE'
    |   'TRIGGER'
    |   'UNDER'
    |   'EXECUTE'
        ;

grantee =
        'PUBLIC'
    |   identifier
        ;

role_definition =
        'CREATE' 'ROLE' identifier ['WITH' 'ADMIN' _KW_GRANTOR]
        ;

grant_role_statement =
        'GRANT' identifier_list
            'TO' grantee_list ['WITH' 'ADMIN' 'OPTION']
            ['GRANTED' 'BY' _KW_GRANTOR]
        ;

revoke_privilege_statement =
        [('GRANT' | 'HIERARCHY') 'OPTION' 'FOR'] privileges
            'FROM' grantee_list ['GRANTED' 'BY' _KW_GRANTOR]
        ;

revoke_role_statement =
        ['ADMIN' 'OPTION' 'FOR'] identifier_list
            'FROM' grantee_list ['GRANTED' 'BY' _KW_GRANTOR]
        ;

schema_definition =
        'CREATE' 'SCHEMA' schema_name_clause
            [schema_character_set_or_path] [{schema_element}+]
        ;

grantee_list =
        ','.{grantee}
        ;

sql_executable_statement =
        sql_schema_statement
    |   sql_data_statement
    |   sql_control_statement
    |   sql_session_statement
    |   sql_dynamic_statement
    |   sql_connection_statement
    |   sql_transaction_statement
    |   sql_diagnostics_statement
        ;

sql_schema_statement =
        sql_schema_definition_statement
    |   sql_schema_manipulation_statement
        ;

sql_schema_definition_statement =
        schema_definition
    |   schema_element
        ;

sql_schema_manipulation_statement =
        'REVOKE' revoke_privilege_statement _KW_DROP_BEHAVIOR
    |   'REVOKE' revoke_role_statement _KW_DROP_BEHAVIOR
    |   'ALTER' alter_routine_statement
    |   'ALTER' alter_transform_statement
    |   'ALTER' 'TABLE' qualified_name alter_table_action
    |   'ALTER' 'DOMAIN' identifier_chain alter_domain_action
    |   'ALTER' 'TYPE' identifier_chain alter_type_action
    |   'ALTER' 'SEQUENCE' identifier_chain {alter_sequence_generator_option}+
    |   'DROP' 'ROLE' identifier
    |   'DROP' 'TRIGGER' identifier_chain
    |   'DROP' 'ASSERTION' identifier_chain
    |   'DROP' 'TRANSLATION' identifier_chain
    |   'DROP' 'CHARACTER' 'SET' identifier_chain
    |   'DROP' 'VIEW' qualified_name _KW_DROP_BEHAVIOR
    |   'DROP' 'TABLE' qualified_name _KW_DROP_BEHAVIOR
    |   'DROP' 'TYPE' identifier_chain _KW_DROP_BEHAVIOR
    |   'DROP' 'SCHEMA' identifier_chain _KW_DROP_BEHAVIOR
    |   'DROP' 'DOMAIN' identifier_chain _KW_DROP_BEHAVIOR
    |   'DROP' 'SEQUENCE' identifier_chain _KW_DROP_BEHAVIOR
    |   'DROP' 'COLLATION' identifier_chain _KW_DROP_BEHAVIOR
    |   'DROP' 'ORDERING' 'FOR' identifier_chain _KW_DROP_BEHAVIOR
    |   'DROP' drop_transform_statement _KW_DROP_BEHAVIOR
    |   'DROP' specific_routine_designator _KW_DROP_BEHAVIOR
    |   'DROP' drop_user_defined_cast_statement _KW_DROP_BEHAVIOR
        ;

sql_data_statement =
        'OPEN' qualified_name
    |   'CLOSE' qualified_name
    |   'FREE' 'LOCATOR' parameter_name_list
    |   'HOLD' 'LOCATOR' parameter_name_list
    |   fetch_statement
    |   data_manipulation_statement
    |   delete_statement_positioned
    |   update_statement_positioned
    |   select_statement_single_row
        ;

sql_control_statement =
        'CALL' routine_invocation
    |   'RETURN' result
        ;

sql_transaction_statement =
        'START' 'TRANSACTION' [transaction_mode_list]
    |   'SET' ['LOCAL'] transaction_characteristics
    |   'SET' 'CONSTRAINTS' constraint_name_list ('DEFERRED' | 'IMMEDIATE')
    |   'SAVEPOINT' identifier
    |   'RELEASE' 'SAVEPOINT' identifier
    |   'COMMIT' ['WORK'] ['AND' ['NO'] 'CHAIN']
    |   'ROLLBACK' ['WORK'] ['AND' ['NO'] 'CHAIN'] ['TO' 'SAVEPOINT' identifier]
        ;

sql_connection_statement =
        'CONNECT' 'TO' connection_target
    |   'SET' 'CONNECTION' connection_object
    |   'DISCONNECT' disconnect_object
        ;

sql_session_statement =
        'SET' 'SESSION' 'AUTHORIZATION' value_specification
    |   'SET' 'ROLE' role_specification
    |   'SET' 'TIME' 'ZONE' set_time_zone_value
    |   'SET' 'SESSION' 'CHARACTERISTICS' 'AS' ','.{transaction_characteristics}
    |   'SET' 'CATALOG' value_specification
    |   'SET' 'SCHEMA' value_specification
    |   'SET' 'NAMES' value_specification
    |   'SET' 'PATH' value_specification
    |   'SET' transform_group_characteristic
    |   'SET' session_collation_statement
        ;

sql_dynamic_statement =
        system_descriptor_statement
    |   sql_dynamic_data_statement
    |   describe_statement
    |   'DEALLOCATE' 'PREPARE' sql_statement_name
    |   'EXECUTE' 'IMMEDIATE' simple_value_specification
    |   'EXECUTE' sql_statement_name [output_using_clause] [input_using_clause]
    |   'PREPARE' sql_statement_name ['ATTRIBUTES' simple_value_specification] 'FROM' simple_value_specification
        ;

sql_dynamic_data_statement =
        'ALLOCATE' descriptor_name cursor_intent
    |   'CLOSE' dynamic_cursor_name
    |   'OPEN' dynamic_cursor_name [input_using_clause]
    |   'DELETE' 'FROM' target_table 'WHERE' 'CURRENT' 'OF' dynamic_cursor_name
    |   'FETCH' [[fetch_orientation] 'FROM'] dynamic_cursor_name output_using_clause
    |   'UPDATE' target_table 'SET' set_clause_list 'WHERE' 'CURRENT' 'OF' dynamic_cursor_name
        ;

system_descriptor_statement =
        'ALLOCATE' ['SQL'] 'DESCRIPTOR' descriptor_name ['WITH' 'MAX' simple_value_specification]
    |   'DEALLOCATE' ['SQL'] 'DESCRIPTOR' descriptor_name
    |   'SET' ['SQL'] 'DESCRIPTOR' descriptor_name set_descriptor_information
    |   'GET' ['SQL'] 'DESCRIPTOR' descriptor_name get_descriptor_information
        ;

order_by_clause =
        'ORDER' 'BY' sort_specification_list
        ;

fetch_statement =
        'FETCH' [[fetch_orientation] 'FROM'] qualified_name
            'INTO' target_specification_list
        ;

fetch_orientation =
        'NEXT'
    |   'PRIOR'
    |   'FIRST'
    |   'LAST'
    |  ('ABSOLUTE' | 'RELATIVE') simple_value_specification
        ;

select_statement_single_row =
        'SELECT' [_KW_SET_QUANTIFIER] select_list
            'INTO' target_specification_list table_expression
        ;

delete_statement_positioned =
        'DELETE' 'FROM' target_table
            'WHERE' 'CURRENT' 'OF' qualified_name
        ;

target_table =
        qualified_name
    |   'ONLY' '(' qualified_name ')'
        ;

delete_statement_searched =
        'DELETE' 'FROM' target_table
            [where_clause]
        ;

insert_statement =
        'INSERT' 'INTO' qualified_name
            insert_columns_and_source
        ;

insert_columns_and_source =
        [par_identifier_list] [_KW_OVERRIDE_CLAUSE] (query_expression | 'VALUES' ','.{contextually_typed_row_value_expression})
    |   'DEFAULT' 'VALUES'
        ;

merge_statement =
        'MERGE' 'INTO' target_table [as_clause]
            'USING' table_reference 'ON'
            boolean_value_expression {merge_when_clause}+
        ;

merge_when_clause =
        'WHEN' 'MATCHED' 'THEN' 'UPDATE' 'SET' set_clause_list
    |   'WHEN' 'NOT' 'MATCHED' 'THEN' merge_insert_specification
        ;

merge_insert_specification =
        'INSERT' [par_identifier_list]
            [_KW_OVERRIDE_CLAUSE] 'VALUES'
            '(' contextually_typed_row_value_constructor_list ')'
        ;

update_statement_positioned =
        'UPDATE' target_table 'SET' set_clause_list
            'WHERE' 'CURRENT' 'OF' qualified_name
        ;

update_statement_searched =
        'UPDATE' target_table 'SET' set_clause_list
            [where_clause]
        ;

set_clause_list =
        ','.{set_clause}
        ;

set_clause =
        '(' ','.{set_target} ')' '=' contextually_typed_row_value_expression
    |   set_target '=' contextually_typed_row_value_constructor_element
        ;

set_target =
        identifier [l_bracket_trigraph simple_value_specification r_bracket_trigraph]
    |   identifier_chain
        ;

temporary_table_declaration =
        'DECLARE' 'LOCAL' 'TEMPORARY'
            'TABLE' qualified_name '(' table_element_list ')'
            ['ON' 'COMMIT' _KW_TABLE_COMMIT_ACTION 'ROWS']
        ;

transaction_mode_list =
        ','.{transaction_mode}
        ;

transaction_mode =
        'ISOLATION' 'LEVEL' _KW_LEVEL_OF_ISOLATION
    |   'READ' ('ONLY' | 'WRITE')
    |   'DIAGNOSTICS' 'SIZE' simple_value_specification
        ;

transaction_characteristics =
        'TRANSACTION' transaction_mode_list
        ;

constraint_name_list =
        'ALL'
    |   identifier_chain_list
        ;

connection_target =
        simple_value_specification ['AS' simple_value_specification] ['USER' simple_value_specification]
    |   'DEFAULT'
        ;

connection_object =
        'DEFAULT'
    |   simple_value_specification
        ;

disconnect_object =
        connection_object
    |   'ALL'
    |   'CURRENT'
        ;

role_specification =
        value_specification
    |   'NONE'
        ;

set_time_zone_value =
        interval_value_expression
    |   'LOCAL'
        ;

transform_group_characteristic =
        'DEFAULT' 'TRANSFORM' 'GROUP' value_specification
    |   'TRANSFORM' 'GROUP' 'FOR' 'TYPE' identifier_chain value_specification
        ;

session_collation_statement =
        ('NO' 'COLLATION' | 'COLLATION' value_specification)
            ['FOR' identifier_chain_list]
        ;

get_descriptor_information =
        ','.{simple_target_specification '=' _KW_HEADER_ITEM_NAME}
    |   'VALUE' simple_value_specification ','.{simple_target_specification '=' _KW_DESCRIPTOR_ITEM_NAME}
        ;

set_descriptor_information =
        ','.{_KW_HEADER_ITEM_NAME '=' simple_value_specification}
    |   'VALUE' simple_value_specification ','.{_KW_DESCRIPTOR_ITEM_NAME '=' simple_value_specification}
        ;

describe_statement =
        'DESCRIBE' ('INPUT' sql_statement_name | ['OUTPUT'] described_object)
            'USING' ['SQL'] 'DESCRIPTOR' descriptor_name
            [_KW_WITH_WITHOUT 'NESTING']
        ;

described_object =
        sql_statement_name
    |   'CURSOR' descriptor_name 'STRUCTURE'
        ;

input_using_clause =
        'USING' ','.{general_value_specification}
    |   'USING' ['SQL'] 'DESCRIPTOR' descriptor_name
        ;

output_using_clause =
        'INTO' target_specification_list
    |   'INTO' ['SQL'] 'DESCRIPTOR' descriptor_name
        ;

target_specification_list =
        ','.{target_specification}
        ;

cursor_intent =
        statement_cursor
    |   'FOR' 'PROCEDURE' specific_routine_designator
        ;

statement_cursor =
        [_KW_CURSOR_SENSITIVITY] [['NO'] 'SCROLL'] 'CURSOR'
            [_KW_WITH_WITHOUT 'HOLD'] [_KW_WITH_WITHOUT 'RETURN']
            'FOR' descriptor_name
        ;

direct_sql_statement =
        ';'.{directly_executable_statement} [';']
        ;

directly_executable_statement =
        direct_sql_data_statement
    |   sql_schema_statement
    |   sql_session_statement
    |   sql_connection_statement
    |   sql_transaction_statement
        ;

direct_sql_data_statement =
        direct_select_statement_multiple_rows
    |   data_manipulation_statement
    |   temporary_table_declaration
        ;

data_manipulation_statement =
        insert_statement
    |   merge_statement
    |   delete_statement_searched
    |   update_statement_searched
        ;

direct_select_statement_multiple_rows =
        query_expression [order_by_clause]
            ['FOR' ('READ' 'ONLY' | 'UPDATE' ['OF' identifier_list])]
        ;

sql_diagnostics_statement =
        'GET' 'DIAGNOSTICS' sql_diagnostics_information
        ;

sql_diagnostics_information =
        ','.{simple_target_specification '=' _KW_STATEMENT_INFORMATION_ITEM}
    |   ('EXCEPTION' | 'CONDITION') simple_value_specification ','.{simple_target_specification '=' _KW_CONDITION_INFORMATION_ITEM}
        ;
