#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__version__ = (2016, 8, 7, 21, 55, 46, 6)

__all__ = [
    'SqlParser',
    'SqlSemantics',
    'main'
]

KEYWORDS = set([])


class SqlBuffer(Buffer):
    def __init__(self,
                 text,
                 whitespace=re.compile('\\s+', RE_FLAGS | re.DOTALL),
                 nameguard=None,
                 comments_re='/\\*[\\s\\S]*?\\*/',
                 eol_comments_re='--.*?$',
                 ignorecase=True,
                 namechars='',
                 **kwargs):
        super(SqlBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class SqlParser(Parser):
    def __init__(self,
                 whitespace=re.compile('\\s+', RE_FLAGS | re.DOTALL),
                 nameguard=None,
                 comments_re='/\\*[\\s\\S]*?\\*/',
                 eol_comments_re='--.*?$',
                 ignorecase=True,
                 left_recursion=True,
                 keywords=KEYWORDS,
                 namechars='',
                 **kwargs):
        super(SqlParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            keywords=keywords,
            namechars=namechars,
            **kwargs
        )

    def parse(self, text, *args, **kwargs):
        if not isinstance(text, Buffer):
            text = SqlBuffer(text, **kwargs)
        return super(SqlParser, self).parse(text, *args, **kwargs)

    @graken()
    def _integer_(self):
        self._pattern(r'\d+')

    @graken()
    def _integer_list_(self):
        self._left_paren_()

        def sep0():
            self._token(',')

        def block0():
            self._integer_()
        self._closure(block0, sep=sep0)
        self._right_paren_()

    @graken()
    def _left_paren_(self):
        self._token('(')

    @graken()
    def _right_paren_(self):
        self._token(')')

    @graken()
    def _regular_identifier_(self):
        self._pattern(r'[a-z]\w*')
        self._check_name()

    @graken()
    def _delimited_identifier_(self):
        self._token('"')
        self._pattern(r'(""|[^"\n])+')
        self._token('"')

    @graken()
    def _general_literal_(self):
        with self._choice():
            with self._option():
                self._chr_str_literal_()
            with self._option():
                self._datetime_literal_()
            with self._option():
                self._interval_literal_()
            with self._option():
                self._token('TRUE')
            with self._option():
                self._token('FALSE')
            with self._option():
                self._token('UNKNOWN')
            self._error('expecting one of: FALSE TRUE UNKNOWN')

    @graken()
    def _chr_str_literal_(self):

        def block0():
            self._token("'")
            self._pattern(r"(''|[^'\n])*")
            self._token("'")
        self._positive_closure(block0)

    @graken()
    def _unsigned_numeric_literal_(self):
        self._decimal_literal_()
        with self._optional():
            self._token('E')
            self._signed_integer_()

    @graken()
    def _proper_decimal_(self):
        self._integer_()
        with self._optional():
            self._token('.')
            with self._optional():
                self._integer_()

    @graken()
    def _decimal_literal_(self):
        with self._choice():
            with self._option():
                self._proper_decimal_()
            with self._option():
                self._token('.')
                self._integer_()
            self._error('no available options')

    @graken()
    def _plus_or_minus_(self):
        with self._choice():
            with self._option():
                self._token('+')
            with self._option():
                self._token('-')
            self._error('expecting one of: + -')

    @graken()
    def _multiply_or_divide_(self):
        with self._choice():
            with self._option():
                self._token('*')
            with self._option():
                self._token('/')
            self._error('expecting one of: * /')

    @graken()
    def _signed_integer_(self):
        with self._optional():
            self._plus_or_minus_()
        self._integer_()

    @graken()
    def _datetime_literal_(self):
        with self._choice():
            with self._option():
                self._token('DATE')
                self._token("'")
                self._integer_()
                self._token('-')
                self._integer_()
                self._token('-')
                self._integer_()
                self._token("'")
            with self._option():
                self._token('TIME')
                self._token("'")
                self._integer_()
                self._token(':')
                self._integer_()
                self._token(':')
                self._proper_decimal_()
                self._token("'")
            with self._option():
                self._token('TIMESTAMP')
                self._token("'")
                self._integer_()
                self._token('-')
                self._integer_()
                self._token('-')
                self._integer_()
                self._integer_()
                self._token(':')
                self._integer_()
                self._token(':')
                self._proper_decimal_()
                self._token("'")
            self._error('no available options')

    @graken()
    def _interval_literal_(self):
        self._token('INTERVAL')
        with self._optional():
            self._plus_or_minus_()
        self._token("'")
        with self._optional():
            self._plus_or_minus_()
        self._unquoted_interval_str_()
        self._token("'")
        self._interval_qualifier_()

    @graken()
    def _unquoted_interval_str_(self):
        with self._choice():
            with self._option():
                self._integer_()
                with self._optional():
                    self._token('-')
                    self._integer_()
            with self._option():
                self._integer_()
                with self._optional():
                    self._integer_()
                    with self._optional():
                        self._token(':')
                        self._integer_()
                        with self._optional():
                            self._token(':')
                            self._proper_decimal_()
            with self._option():
                self._integer_()
                with self._optional():
                    self._token(':')
                    self._integer_()
                    with self._optional():
                        self._token(':')
                        self._proper_decimal_()
            with self._option():
                self._integer_()
                with self._optional():
                    self._token(':')
                    self._proper_decimal_()
            with self._option():
                self._proper_decimal_()
            self._error('no available options')

    @graken()
    def _name_list_(self):

        def sep0():
            self._token(',')

        def block0():
            self._qualified_name_()
        self._closure(block0, sep=sep0)

    @graken()
    def _identifier_(self):
        with self._choice():
            with self._option():
                self._regular_identifier_()
            with self._option():
                self._delimited_identifier_()
            self._error('no available options')

    @graken()
    def _qualified_name_(self):
        with self._optional():
            self._token('MODULE')
            self._token('.')
        self._identifier_chain_()

    @graken()
    def _parameter_name_(self):
        self._token(':')
        self._identifier_()

    @graken()
    def _data_type_(self):
        with self._choice():
            with self._option():
                self._token('CHARACTER')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('CHAR')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('NUMERIC')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('DECIMAL')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('DEC')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('SMALLINT')
            with self._option():
                self._token('INTEGER')
            with self._option():
                self._token('INT')
            with self._option():
                self._token('BIGINT')
            with self._option():
                self._token('FLOAT')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('REAL')
            with self._option():
                self._token('DOUBLE')
                self._token('PRECISION')
            with self._option():
                self._token('BOOLEAN')
            with self._option():
                self._token('DATE')
            with self._option():
                self._token('TIME')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('TIMESTAMP')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('INTERVAL')
                self._interval_qualifier_()
            self._error('expecting one of: BIGINT BOOLEAN CHAR CHARACTER DATE DEC DECIMAL DOUBLE FLOAT INT INTEGER NUMERIC REAL SMALLINT TIME TIMESTAMP')

    @graken()
    def _value_expr_primary_(self):
        with self._choice():
            with self._option():
                self._token('DECODE')
                self._value_expr_list_()
            with self._option():
                self._rank_function_type_()
                self._empty_set_()
                self._token('OVER')
                self._window_spec_()
            with self._option():
                self._token('ROW_NUMBER')
                self._empty_set_()
                self._token('OVER')
                self._window_spec_()
            with self._option():
                self._aggregate_function_()
                with self._optional():
                    self._token('OVER')
                    self._window_spec_()
            with self._option():
                self._subquery_()
            with self._option():
                self._token('NULLIF')
                self._value_expr_list_()
            with self._option():
                self._token('LENGTH')
                self._value_expr_list_()
            with self._option():
                self._token('COALESCE')
                self._value_expr_list_()
            with self._option():
                self._token('SUBSTR')
                self._value_expr_list_()
            with self._option():
                self._token('REGEXP_SUBSTR')
                self._value_expr_list_()
            with self._option():
                self._token('REGEXP_REPLACE')
                self._value_expr_list_()
            with self._option():
                self._case_expr_()
            with self._option():
                self._token('CAST')
                self._left_paren_()
                self._result_()
                self._token('AS')
                self._data_type_()
                self._right_paren_()
            with self._option():
                self._token('TREAT')
                self._left_paren_()
                self._value_expr_()
                self._token('AS')
                self._qualified_name_()
                self._right_paren_()
            with self._option():
                self._unsigned_numeric_literal_()
            with self._option():
                self._general_literal_()
            with self._option():
                self._parameter_name_()
            with self._option():
                self._token('?')
            with self._option():
                self._token('CURRENT_ROLE')
            with self._option():
                self._token('CURRENT_USER')
            with self._option():
                self._token('SESSION_USER')
            with self._option():
                self._token('SYSTEM_USER')
            with self._option():
                self._token('USER')
            with self._option():
                self._token('VALUE')
            with self._option():
                self._qualified_name_()
            self._error('expecting one of: ? CURRENT_ROLE CURRENT_USER SESSION_USER SYSTEM_USER USER VALUE')

    @graken()
    def _identifier_chain_(self):

        def sep0():
            self._token('.')

        def block0():
            self._identifier_()
        self._closure(block0, sep=sep0)

    @graken()
    def _rank_function_type_(self):
        with self._choice():
            with self._option():
                self._token('RANK')
            with self._option():
                self._token('DENSE_RANK')
            with self._option():
                self._token('PERCENT_RANK')
            with self._option():
                self._token('CUME_DIST')
            self._error('expecting one of: CUME_DIST DENSE_RANK PERCENT_RANK RANK')

    @graken()
    def _value_expr_list_(self):
        self._left_paren_()

        def sep0():
            self._token(',')

        def block0():
            self._value_expr_()
        self._closure(block0, sep=sep0)
        self._right_paren_()

    @graken()
    def _case_expr_(self):
        with self._choice():
            with self._option():
                self._token('CASE')
                self._value_expr_()

                def block0():
                    self._simple_when_clause_()
                self._positive_closure(block0)
                with self._optional():
                    self._else_clause_()
                self._token('END')
            with self._option():
                self._token('CASE')

                def block1():
                    self._searched_when_clause_()
                self._positive_closure(block1)
                with self._optional():
                    self._else_clause_()
                self._token('END')
            self._error('no available options')

    @graken()
    def _simple_when_clause_(self):
        self._token('WHEN')
        self._when_operand_list_()
        self._token('THEN')
        self._result_()

    @graken()
    def _searched_when_clause_(self):
        self._token('WHEN')
        self._boolean_value_expr_()
        self._token('THEN')
        self._result_()

    @graken()
    def _else_clause_(self):
        self._token('ELSE')
        self._result_()

    @graken()
    def _when_operand_list_(self):

        def sep0():
            self._token(',')

        def block0():
            self._when_operand_()
        self._closure(block0, sep=sep0)

    @graken()
    def _when_operand_(self):
        with self._choice():
            with self._option():
                self._part_predicate_()
            with self._option():
                self._value_expr_()
            self._error('no available options')

    @graken()
    def _part_predicate_(self):
        with self._choice():
            with self._option():
                self._comp_op_()
                self._value_expr_()
            with self._option():
                self._comp_op_()
                self._quantifier_()
                self._subquery_()
            with self._option():
                self._token('OVERLAPS')
                self._value_expr_()
            with self._option():
                self._token('IS')
                with self._optional():
                    self._token('NOT')
                self._token('NULL')
            with self._option():
                self._token('IS')
                with self._optional():
                    self._token('NOT')
                self._token('NORMALIZED')
            with self._option():
                self._token('IS')
                with self._optional():
                    self._token('NOT')
                self._token('DISTINCT')
                self._token('FROM')
                self._value_expr_()
            with self._option():
                with self._optional():
                    self._token('NOT')
                self._token('IN')
                self._in_predicate_value_()
            with self._option():
                with self._optional():
                    self._token('NOT')
                self._token('LIKE')
                self._value_expr_()
            with self._option():
                with self._optional():
                    self._token('NOT')
                self._token('BETWEEN')
                self._value_expr_()
                self._token('AND')
                self._value_expr_()
            self._error('expecting one of: IS')

    @graken()
    def _result_(self):
        with self._choice():
            with self._option():
                self._token('NULL')
            with self._option():
                self._value_expr_()
            self._error('expecting one of: NULL')

    @graken()
    def _value_expr_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._value_expr_()
                    self._ops_()
                with self._optional():
                    self._plus_or_minus_()
                self._primary_()
            with self._option():
                self._boolean_value_expr_()
            self._error('no available options')

    @graken()
    def _ops_(self):
        with self._choice():
            with self._option():
                self._plus_or_minus_()
            with self._option():
                self._multiply_or_divide_()
            with self._option():
                self._token('||')
            self._error('expecting one of: ||')

    @graken()
    def _primary_(self):
        with self._choice():
            with self._option():
                self._token('POSITION')
                self._left_paren_()
                self._value_expr_()
                self._token('IN')
                self._value_expr_()
                self._right_paren_()
            with self._option():
                self._token('EXTRACT')
                self._left_paren_()
                self._extract_field_()
                self._token('FROM')
                self._value_expr_()
                self._right_paren_()
            with self._option():
                self._token('CHAR_LENGTH')
                self._value_expr_list_()
            with self._option():
                self._token('CHARACTER_LENGTH')
                self._value_expr_list_()
            with self._option():
                self._token('OCTET_LENGTH')
                self._value_expr_list_()
            with self._option():
                self._token('ABS')
                self._value_expr_list_()
            with self._option():
                self._token('MOD')
                self._value_expr_list_()
            with self._option():
                self._token('LN')
                self._value_expr_list_()
            with self._option():
                self._token('EXP')
                self._value_expr_list_()
            with self._option():
                self._token('POWER')
                self._value_expr_list_()
            with self._option():
                self._token('SQRT')
                self._value_expr_list_()
            with self._option():
                self._token('FLOOR')
                self._value_expr_list_()
            with self._option():
                self._token('CEIL')
                self._value_expr_list_()
            with self._option():
                self._token('CEILING')
                self._value_expr_list_()
            with self._option():
                self._token('WIDTH_BUCKET')
                self._value_expr_list_()
            with self._option():
                self._token('SUBSTRING')
                self._left_paren_()
                self._value_expr_()
                self._token('FROM')
                self._value_expr_()
                with self._optional():
                    self._token('FOR')
                    self._value_expr_()
                self._right_paren_()
            with self._option():
                self._token('UPPER')
                self._value_expr_list_()
            with self._option():
                self._token('LOWER')
                self._value_expr_list_()
            with self._option():
                self._token('TRIM')
                self._value_expr_list_()
            with self._option():
                self._token('NORMALIZE')
                self._value_expr_list_()
            with self._option():
                self._token('CURRENT_DATE')
            with self._option():
                self._token('CURRENT_TIME')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('CURRENT_TIMESTAMP')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('LOCALTIME')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._token('LOCALTIMESTAMP')
                with self._optional():
                    self._integer_list_()
            with self._option():
                self._value_expr_list_()
            with self._option():
                self._value_expr_primary_()
            self._error('expecting one of: CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP LOCALTIME LOCALTIMESTAMP')

    @graken()
    def _extract_field_(self):
        with self._choice():
            with self._option():
                self._primary_datetime_field_()
            with self._option():
                self._token('TIMEZONE_HOUR')
            with self._option():
                self._token('TIMEZONE_MINUTE')
            self._error('expecting one of: TIMEZONE_HOUR TIMEZONE_MINUTE')

    @graken()
    def _boolean_value_expr_(self):
        with self._optional():
            self._token('NOT')
        self._boolean_primary_()
        with self._optional():

            def block0():
                self._and_or_()
                with self._optional():
                    self._token('NOT')
                self._boolean_primary_()
            self._positive_closure(block0)

    @graken()
    def _and_or_(self):
        with self._choice():
            with self._option():
                self._token('AND')
            with self._option():
                self._token('OR')
            self._error('expecting one of: AND OR')

    @graken()
    def _boolean_primary_(self):
        with self._choice():
            with self._option():
                self._value_expr_()
                self._part_predicate_()
            with self._option():
                self._token('EXISTS')
                self._subquery_()
            with self._option():
                self._token('UNIQUE')
                self._subquery_()
            with self._option():
                self._left_paren_()
                self._boolean_value_expr_()
                self._right_paren_()
            with self._option():
                self._value_expr_primary_()
            self._error('no available options')

    @graken()
    def _all_distinct_(self):
        with self._choice():
            with self._option():
                self._token('ALL')
            with self._option():
                self._token('DISTINCT')
            self._error('expecting one of: ALL DISTINCT')

    @graken()
    def _table_expr_(self):
        self._from_clause_()
        with self._optional():
            self._where_clause_()
        with self._optional():
            self._group_by_clause_()
        with self._optional():
            self._having_clause_()
        with self._optional():
            self._connect_clause_()

    @graken()
    def _connect_clause_(self):
        self._token('CONNECT')
        self._token('BY')
        self._boolean_value_expr_()

    @graken()
    def _from_clause_(self):
        self._token('FROM')
        self._table_reference_list_()

    @graken()
    def _table_reference_list_(self):

        def sep0():
            self._token(',')

        def block0():
            self._table_reference_()
        self._closure(block0, sep=sep0)

    @graken()
    def _table_reference_(self):
        with self._choice():
            with self._option():
                self._joined_table_()
            with self._option():
                self._table_primary_()
            self._error('no available options')

    @graken()
    def _table_primary_(self):
        with self._choice():
            with self._option():
                self._left_paren_()
                self._joined_table_()
                self._right_paren_()
            with self._option():
                self._subquery_()
                with self._optional():
                    self._as_clause_()
            with self._option():
                self._qualified_name_()
                with self._optional():
                    self._as_clause_()
            self._error('no available options')

    @graken()
    def _joined_table_(self):
        with self._choice():
            with self._option():
                self._table_reference_()
                self._token('CROSS')
                self._token('JOIN')
                self._table_primary_()
            with self._option():
                self._table_reference_()
                with self._optional():
                    self._join_type_()
                self._token('JOIN')
                self._table_reference_()
                self._token('ON')
                self._boolean_value_expr_()
            with self._option():
                self._table_reference_()
                self._token('NATURAL')
                with self._optional():
                    self._join_type_()
                self._token('JOIN')
                self._table_primary_()
            self._error('no available options')

    @graken()
    def _join_type_(self):
        with self._choice():
            with self._option():
                self._token('INNER')
            with self._option():
                self._outer_join_type_()
                with self._optional():
                    self._token('OUTER')
            self._error('expecting one of: INNER')

    @graken()
    def _outer_join_type_(self):
        with self._choice():
            with self._option():
                self._token('LEFT')
            with self._option():
                self._token('RIGHT')
            with self._option():
                self._token('FULL')
            self._error('expecting one of: FULL LEFT RIGHT')

    @graken()
    def _where_clause_(self):
        self._token('WHERE')
        self._boolean_value_expr_()

    @graken()
    def _group_by_clause_(self):
        self._token('GROUP')
        self._token('BY')
        with self._optional():
            self._all_distinct_()
        self._grouping_element_list_()

    @graken()
    def _grouping_element_list_(self):

        def sep0():
            self._token(',')

        def block0():
            self._grouping_set_()
        self._closure(block0, sep=sep0)

    @graken()
    def _ordinary_grouping_set_(self):
        with self._choice():
            with self._option():
                self._left_paren_()
                self._name_list_()
                self._right_paren_()
            with self._option():
                self._qualified_name_()
            self._error('no available options')

    @graken()
    def _grouping_set_(self):
        with self._choice():
            with self._option():
                self._ordinary_grouping_set_()
            with self._option():
                self._empty_set_()
            self._error('no available options')

    @graken()
    def _empty_set_(self):
        self._left_paren_()
        self._right_paren_()

    @graken()
    def _having_clause_(self):
        self._token('HAVING')
        self._boolean_value_expr_()

    @graken()
    def _window_spec_(self):
        self._left_paren_()
        with self._optional():
            self._partition_clause_()
        with self._optional():
            self._order_by_clause_()
        self._right_paren_()

    @graken()
    def _partition_clause_(self):
        self._token('PARTITION')
        self._token('BY')
        self._name_list_()

    @graken()
    def _select_list_(self):
        with self._choice():
            with self._option():
                self._token('*')
            with self._option():

                def sep0():
                    self._token(',')

                def block0():
                    self._select_sublist_()
                self._closure(block0, sep=sep0)
            self._error('expecting one of: *')

    @graken()
    def _select_sublist_(self):
        with self._choice():
            with self._option():
                self._value_expr_()
                with self._optional():
                    self._as_clause_()
            with self._option():
                self._qualified_name_()
                self._token('.')
                self._token('*')
            self._error('no available options')

    @graken()
    def _as_clause_(self):
        with self._optional():
            self._token('AS')
        self._identifier_()

    @graken()
    def _query_expr_(self):
        with self._optional():
            self._token('WITH')
            self._with_list_()
        self._query_expr_body_()

    @graken()
    def _with_list_(self):

        def sep0():
            self._token(',')

        def block0():
            self._identifier_()
            self._token('AS')
            self._subquery_()
        self._closure(block0, sep=sep0)

    @graken()
    def _query_expr_body_(self):
        self._query_primary_()
        with self._optional():

            def block0():
                self._union_except_()
                with self._optional():
                    self._all_distinct_()
                self._query_primary_()
            self._positive_closure(block0)

    @graken()
    def _union_except_(self):
        with self._choice():
            with self._option():
                self._token('UNION')
            with self._option():
                self._token('EXCEPT')
            with self._option():
                self._token('INTERSECT')
            self._error('expecting one of: EXCEPT INTERSECT UNION')

    @graken()
    def _query_primary_(self):
        with self._choice():
            with self._option():
                self._token('SELECT')
                with self._optional():
                    self._all_distinct_()
                self._select_list_()
                self._table_expr_()
            with self._option():
                self._left_paren_()
                self._query_expr_body_()
                self._right_paren_()
            self._error('no available options')

    @graken()
    def _subquery_(self):
        self._left_paren_()
        self._query_expr_()
        self._right_paren_()

    @graken()
    def _comp_op_(self):
        with self._choice():
            with self._option():
                self._token('<=')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('<>')
            with self._option():
                self._token('=')
            with self._option():
                self._token('!=')
            with self._option():
                self._token('<')
            with self._option():
                self._token('>')
            self._error('expecting one of: != < <= <> = > >=')

    @graken()
    def _in_predicate_value_(self):
        with self._choice():
            with self._option():
                self._subquery_()
            with self._option():
                self._value_expr_list_()
            self._error('no available options')

    @graken()
    def _quantifier_(self):
        with self._choice():
            with self._option():
                self._token('ALL')
            with self._option():
                self._token('SOME')
            with self._option():
                self._token('ANY')
            self._error('expecting one of: ALL ANY SOME')

    @graken()
    def _interval_qualifier_(self):
        self._primary_datetime_field_()
        with self._optional():
            self._integer_list_()
        with self._optional():
            self._token('TO')
            self._primary_datetime_field_()
            with self._optional():
                self._integer_list_()

    @graken()
    def _primary_datetime_field_(self):
        with self._choice():
            with self._option():
                self._token('YEAR')
            with self._option():
                self._token('MONTH')
            with self._option():
                self._token('DAY')
            with self._option():
                self._token('HOUR')
            with self._option():
                self._token('MINUTE')
            with self._option():
                self._token('SECOND')
            self._error('expecting one of: DAY HOUR MINUTE MONTH SECOND YEAR')

    @graken()
    def _aggregate_function_(self):
        with self._choice():
            with self._option():
                self._token('COUNT')
                self._left_paren_()
                self._token('*')
                self._right_paren_()
                with self._optional():
                    self._filter_clause_()
            with self._option():
                self._computational_operation_()
                self._left_paren_()
                with self._optional():
                    self._all_distinct_()
                self._value_expr_()
                self._right_paren_()
                with self._optional():
                    self._filter_clause_()
            self._error('no available options')

    @graken()
    def _computational_operation_(self):
        with self._choice():
            with self._option():
                self._token('AVG')
            with self._option():
                self._token('MAX')
            with self._option():
                self._token('MIN')
            with self._option():
                self._token('SUM')
            with self._option():
                self._token('EVERY')
            with self._option():
                self._token('ANY')
            with self._option():
                self._token('LEAD')
            with self._option():
                self._token('LAG')
            with self._option():
                self._token('SOME')
            with self._option():
                self._token('COUNT')
            with self._option():
                self._token('STDDEV_POP')
            with self._option():
                self._token('STDDEV_SAMP')
            with self._option():
                self._token('VAR_SAMP')
            with self._option():
                self._token('VAR_POP')
            with self._option():
                self._token('COLLECT')
            with self._option():
                self._token('FUSION')
            with self._option():
                self._token('INTERSECTION')
            self._error('expecting one of: ANY AVG COLLECT COUNT EVERY FUSION INTERSECTION LAG LEAD MAX MIN SOME STDDEV_POP STDDEV_SAMP SUM VAR_POP VAR_SAMP')

    @graken()
    def _filter_clause_(self):
        self._token('FILTER')
        self._left_paren_()
        self._where_clause_()
        self._right_paren_()

    @graken()
    def _sort_spec_list_(self):

        def sep0():
            self._token(',')

        def block0():
            self._sort_spec_()
        self._closure(block0, sep=sep0)

    @graken()
    def _sort_spec_(self):
        self._value_expr_()
        with self._optional():
            self._ordering_spec_()
        with self._optional():
            self._null_ordering_()

    @graken()
    def _ordering_spec_(self):
        with self._choice():
            with self._option():
                self._token('ASC')
            with self._option():
                self._token('DESC')
            self._error('expecting one of: ASC DESC')

    @graken()
    def _null_ordering_(self):
        with self._choice():
            with self._option():
                self._token('NULLS')
                self._token('FIRST')
            with self._option():
                self._token('NULLS')
                self._token('LAST')
            self._error('expecting one of: NULLS')

    @graken()
    def _cursor_spec_(self):
        self._query_expr_()
        with self._optional():
            self._order_by_clause_()

    @graken()
    def _order_by_clause_(self):
        self._token('ORDER')
        self._token('BY')
        self._sort_spec_list_()

    @graken()
    def _start_(self):
        self._cursor_spec_()
        self._check_eof()


class SqlSemantics(object):
    def integer(self, ast):
        return ast

    def integer_list(self, ast):
        return ast

    def left_paren(self, ast):
        return ast

    def right_paren(self, ast):
        return ast

    def regular_identifier(self, ast):
        return ast

    def delimited_identifier(self, ast):
        return ast

    def general_literal(self, ast):
        return ast

    def chr_str_literal(self, ast):
        return ast

    def unsigned_numeric_literal(self, ast):
        return ast

    def proper_decimal(self, ast):
        return ast

    def decimal_literal(self, ast):
        return ast

    def plus_or_minus(self, ast):
        return ast

    def multiply_or_divide(self, ast):
        return ast

    def signed_integer(self, ast):
        return ast

    def datetime_literal(self, ast):
        return ast

    def interval_literal(self, ast):
        return ast

    def unquoted_interval_str(self, ast):
        return ast

    def name_list(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def qualified_name(self, ast):
        return ast

    def parameter_name(self, ast):
        return ast

    def data_type(self, ast):
        return ast

    def value_expr_primary(self, ast):
        return ast

    def identifier_chain(self, ast):
        return ast

    def rank_function_type(self, ast):
        return ast

    def value_expr_list(self, ast):
        return ast

    def case_expr(self, ast):
        return ast

    def simple_when_clause(self, ast):
        return ast

    def searched_when_clause(self, ast):
        return ast

    def else_clause(self, ast):
        return ast

    def when_operand_list(self, ast):
        return ast

    def when_operand(self, ast):
        return ast

    def part_predicate(self, ast):
        return ast

    def result(self, ast):
        return ast

    def value_expr(self, ast):
        return ast

    def ops(self, ast):
        return ast

    def primary(self, ast):
        return ast

    def extract_field(self, ast):
        return ast

    def boolean_value_expr(self, ast):
        return ast

    def and_or(self, ast):
        return ast

    def boolean_primary(self, ast):
        return ast

    def all_distinct(self, ast):
        return ast

    def table_expr(self, ast):
        return ast

    def connect_clause(self, ast):
        return ast

    def from_clause(self, ast):
        return ast

    def table_reference_list(self, ast):
        return ast

    def table_reference(self, ast):
        return ast

    def table_primary(self, ast):
        return ast

    def joined_table(self, ast):
        return ast

    def join_type(self, ast):
        return ast

    def outer_join_type(self, ast):
        return ast

    def where_clause(self, ast):
        return ast

    def group_by_clause(self, ast):
        return ast

    def grouping_element_list(self, ast):
        return ast

    def ordinary_grouping_set(self, ast):
        return ast

    def grouping_set(self, ast):
        return ast

    def empty_set(self, ast):
        return ast

    def having_clause(self, ast):
        return ast

    def window_spec(self, ast):
        return ast

    def partition_clause(self, ast):
        return ast

    def select_list(self, ast):
        return ast

    def select_sublist(self, ast):
        return ast

    def as_clause(self, ast):
        return ast

    def query_expr(self, ast):
        return ast

    def with_list(self, ast):
        return ast

    def query_expr_body(self, ast):
        return ast

    def union_except(self, ast):
        return ast

    def query_primary(self, ast):
        return ast

    def subquery(self, ast):
        return ast

    def comp_op(self, ast):
        return ast

    def in_predicate_value(self, ast):
        return ast

    def quantifier(self, ast):
        return ast

    def interval_qualifier(self, ast):
        return ast

    def primary_datetime_field(self, ast):
        return ast

    def aggregate_function(self, ast):
        return ast

    def computational_operation(self, ast):
        return ast

    def filter_clause(self, ast):
        return ast

    def sort_spec_list(self, ast):
        return ast

    def sort_spec(self, ast):
        return ast

    def ordering_spec(self, ast):
        return ast

    def null_ordering(self, ast):
        return ast

    def cursor_spec(self, ast):
        return ast

    def order_by_clause(self, ast):
        return ast

    def start(self, ast):
        return ast


def main(
        filename,
        startrule,
        trace=False,
        whitespace=None,
        nameguard=None,
        comments_re='/\\*[\\s\\S]*?\\*/',
        eol_comments_re='--.*?$',
        ignorecase=True,
        left_recursion=True,
        **kwargs):

    with open(filename) as f:
        text = f.read()
    whitespace = whitespace or re.compile('\\s+', RE_FLAGS | re.DOTALL)
    parser = SqlParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard,
        ignorecase=ignorecase,
        **kwargs)
    return ast

if __name__ == '__main__':
    import json
    ast = generic_main(main, SqlParser, name='Sql')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()
